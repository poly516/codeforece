1017C The Phone Number
http://codeforces.com/contest/1017/problem/C
-------------------------------------------------------------------------------------------------------------------------------------------
题目意思:
题目会输入n,表示会有1-n。
要求你把1-n按一定的顺序排列,
使得:
从左往右所选择的k个数由大往小,最大值为f1。
从左往右所选择的k个数由小往大,最大值为f2。
最终的f1+f2最小。
要你将其中一个可能的数列输出。
-------------------------------------------------------------------------------------------------------------------------------------------
解题思路:
将其分成i份,这样的话,f1=(n+i-1)/i,f2=i。
因为每一份都按从小往大来,
所以LIS就是从小到最大共(n+i-1)/i个数。
然后就取每一份的最后一个组成LDS。
这样输出便可以满足要求了
-------------------------------------------------------------------------------------------------------------------------------------------
伪代码:
for (int i=2;i<=n;i++) //判定份数(i为份数);
for (int i=n-(n+mx-1)/mx+1;i<=n;i++) cout<<i<<' ';//n-(n+mx-1)/mx共(n+mx-1)/mx个数。
n-=(n+mx-1)/mx;mx-=1;
while (n>0){
	for (int i=n-n/mx+1;i<=n;i++) cout<<i<<' ';
	n=n-n/mx;mx-=1;
}
-------------------------------------------------------------------------------------------------------------------------------------------
错误原因:
一开始的时候,
因为方法出了错————只分成了两端,
这样子的话在n=9的时候就会不满足要求了。
因此这个方法是错误的。
for (int i=n-(n+1)/2+1;i<=n;i++) cout<<i<<' ';
if (n%2==0)
	for (int i=1;i<=(n+1)/2;i++) cout<<i<<' ';
else
	for (int i=1;i<=(n+1)/2-1;i++) cout<<i<<' ';
之后便根据样例分析,
得到了新的一种思路。
