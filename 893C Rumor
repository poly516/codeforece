http://codeforces.com/problemset/problem/893/C
893C Rumor
-------------------------------------------------------------------------------------------------------------------------------------------
题目意思：
已知共有n个人物，你想要去贿赂他们。
其中有共有n-1对人是朋友关系，
他们被贿赂了之后，会无偿分给他的朋友。
你也相当于将他的朋友贿赂了。
你知道贿赂一个人所需要的代价是多少。
问你将所有人贿赂一遍所要花费的最少代价是多少。
-------------------------------------------------------------------------------------------------------------------------------------------
解题思路：
利用dfs，从一个还没有贿赂过的人起，
将所有与之相关联的人搜索一遍，找到所需要的最小值，
要记录该点是否已经选择，避免重复计算。
-------------------------------------------------------------------------------------------------------------------------------------------
伪代码：
void dfs(long long last){
	for (long long i=0;i<v[last].size();i++)
		if (f[v[last][i]]==0){
			f[v[last][i]]=1;
			dfs(v[last][i]);
			num=min(num,c[v[last][i]]);
		}
}
int main(){
//用散列表表示人与人之间的关系
	for (long long i=1;i<=n;i++)
		if (f[i]==0){
			f[i]=1;
			num=c[i];
			dfs(i);
			ans+=num;
		}
}
-------------------------------------------------------------------------------------------------------------------------------------------
错误原因：
一开始是利用vector来表示。
其中，第一个表示贿赂这些人所需要的最小值，
后面则是有关系的人。
通过不断的合并与添加来维持。
但在这其中，不断地搜索是否有这一个人，或判断他在哪，
会耗费大量的时间。
